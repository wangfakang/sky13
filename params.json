{"name":"Sky13","tagline":"nginx reload 过程","body":"`nginx -s reload对性能的影响`    \r\n\r\n一.nginx reload的过程:\r\n=====\r\n   首先是nginx执行这样一个命令其nginx的内部hi如何做的恩?其整个过程是这样的------首先fork新worker子进程进行读取配\r\n置文件内容进行初始化新的worker进程.然后nginx master进程就会通知worker子进程,让其不在listen fd[即\r\n旧的worker进程不在接受新的连接请求].    \r\n\r\n二.注意其实在执行nginx -s reload会有这样几个问题:   \r\n=====\r\n \r\n##  1.若有大量请求,此时会丢请求.  \r\n   * 原因是:在某一时刻nginx的worker进程是之前的二倍,导致系统资源的下降[并发自然也下降了qps]而且多个worker之间进\r\n行锁的竞争.      \r\n   \r\n## 2.若此时worker子进程比较多则会很耗费内存.    \r\n  * 由于老的worker子进程要把当前的请求的任务处理完成才会释放worker进程的资源,所以若果老的worker和后端的机器\r\nkeepalive什么的话则在一段时间内nginx的worker进程个数会随着reload的次数成倍数增加.      \r\n\r\n三.代码分析:\r\n====\r\n\r\n```c\r\n  //ngx_reconfigure标志位为1，重新读取配置文件  \r\n  //nginx不会让原来的worker子进程再重新读取配置文件，其策略是重新初始化ngx_cycle_t结构体，\r\n  //用它来读取新的额配置文件再创建新的额worker子进程，销毁旧的worker子进程  \r\n        if (ngx_reconfigure) {  \r\n            ngx_reconfigure = 0;  \r\n  \r\n            //ngx_new_binary标志位为1，平滑升级Nginx  \r\n            if (ngx_new_binary) {  \r\n                ngx_start_worker_processes(cycle, ccf->worker_processes,  \r\n                                           NGX_PROCESS_RESPAWN);  \r\n                ngx_start_cache_manager_processes(cycle, 0);  \r\n                ngx_noaccepting = 0;  \r\n  \r\n                continue;  \r\n            }  \r\n  \r\n            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, \"reconfiguring\");  \r\n  \r\n            //初始化ngx_cycle_t结构体  \r\n            cycle = ngx_init_cycle(cycle);  \r\n            if (cycle == NULL) {  \r\n                cycle = (ngx_cycle_t *) ngx_cycle;  \r\n                continue;  \r\n            }  \r\n  \r\n            ngx_cycle = cycle;  \r\n            ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx,  \r\n                                                   ngx_core_module);  \r\n            //创建新的worker子进程  \r\n            ngx_start_worker_processes(cycle, ccf->worker_processes,  \r\n                                       NGX_PROCESS_JUST_RESPAWN);  \r\n            ngx_start_cache_manager_processes(cycle, 1);  \r\n  \r\n            /* allow new processes to start */  \r\n            ngx_msleep(100);  \r\n  \r\n            live = 1;  \r\n            //向所有子进程发送QUIT信号  \r\n            ngx_signal_worker_processes(cycle,  \r\n                                        ngx_signal_value(NGX_SHUTDOWN_SIGNAL));  \r\n        }  \r\n\r\n\r\n\r\n```\r\n\r\n\r\n欢迎一起交流学习 \r\n====\r\n \r\n在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流\r\n\r\n* 邮件(1031379296#qq.com, 把#换成@)\r\n* QQ: 1031379296\r\n* weibo: [@王发康](http://weibo.com/u/2786211992/home)\r\n\r\n\r\nThx\r\n====\r\n\r\n* chunshengsterATgmail.com\r\n\r\n\r\nAuthor\r\n====\r\n* Linux\\nginx\\golang\\c\\c++爱好者\r\n* 欢迎一起交流  一起学习# \r\n* Others say good and Others good\r\n\r\n\r\n","google":"nginx reload 的过程 性能的影响","note":"Don't delete this file! It's used internally to help with page regeneration."}