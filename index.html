<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Sky13 by wangfakang</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Sky13</h1>
        <p class="header">nginx reload 过程</p>

        <ul>
          <li class="download"><a class="buttons" href="https://github.com/wangfakang/sky13/zipball/master">Download ZIP</a></li>
          <li class="download"><a class="buttons" href="https://github.com/wangfakang/sky13/tarball/master">Download TAR</a></li>
          <li><a class="buttons github" href="https://github.com/wangfakang/sky13">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/wangfakang">wangfakang</a></p>


      </header>
      <section>
        <p><code>nginx -s reload对性能的影响</code>    </p>

<h1>
<a id="一nginx-reload的过程" class="anchor" href="#%E4%B8%80nginx-reload%E7%9A%84%E8%BF%87%E7%A8%8B" aria-hidden="true"><span class="octicon octicon-link"></span></a>一.nginx reload的过程:</h1>

<p>首先是nginx执行这样一个命令其nginx的内部hi如何做的恩?其整个过程是这样的------首先fork新worker子进程进行读取配
置文件内容进行初始化新的worker进程.然后nginx master进程就会通知worker子进程,让其不在listen fd[即
旧的worker进程不在接受新的连接请求].    </p>

<h1>
<a id="二注意其实在执行nginx--s-reload会有这样几个问题---" class="anchor" href="#%E4%BA%8C%E6%B3%A8%E6%84%8F%E5%85%B6%E5%AE%9E%E5%9C%A8%E6%89%A7%E8%A1%8Cnginx--s-reload%E4%BC%9A%E6%9C%89%E8%BF%99%E6%A0%B7%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98---" aria-hidden="true"><span class="octicon octicon-link"></span></a>二.注意其实在执行nginx -s reload会有这样几个问题:   </h1>

<h2>
<a id="1若有大量请求此时会丢请求" class="anchor" href="#1%E8%8B%A5%E6%9C%89%E5%A4%A7%E9%87%8F%E8%AF%B7%E6%B1%82%E6%AD%A4%E6%97%B6%E4%BC%9A%E4%B8%A2%E8%AF%B7%E6%B1%82" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.若有大量请求,此时会丢请求.</h2>

<ul>
<li>原因是:在某一时刻nginx的worker进程是之前的二倍,导致系统资源的下降[并发自然也下降了qps]而且多个worker之间进
行锁的竞争.<br>
</li>
</ul>

<h2>
<a id="2若此时worker子进程比较多则会很耗费内存" class="anchor" href="#2%E8%8B%A5%E6%AD%A4%E6%97%B6worker%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%AF%94%E8%BE%83%E5%A4%9A%E5%88%99%E4%BC%9A%E5%BE%88%E8%80%97%E8%B4%B9%E5%86%85%E5%AD%98" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.若此时worker子进程比较多则会很耗费内存.</h2>

<ul>
<li>由于老的worker子进程要把当前的请求的任务处理完成才会释放worker进程的资源,所以若果老的worker和后端的机器
keepalive什么的话则在一段时间内nginx的worker进程个数会随着reload的次数成倍数增加.<br>
</li>
</ul>

<h1>
<a id="三代码分析" class="anchor" href="#%E4%B8%89%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>三.代码分析:</h1>

<div class="highlight highlight-source-c"><pre>  <span class="pl-c">//ngx_reconfigure标志位为1，重新读取配置文件  </span>
  <span class="pl-c">//nginx不会让原来的worker子进程再重新读取配置文件，其策略是重新初始化ngx_cycle_t结构体，</span>
  <span class="pl-c">//用它来读取新的额配置文件再创建新的额worker子进程，销毁旧的worker子进程  </span>
        <span class="pl-k">if</span> (ngx_reconfigure) {  
            ngx_reconfigure = <span class="pl-c1">0</span>;  

            <span class="pl-c">//ngx_new_binary标志位为1，平滑升级Nginx  </span>
            <span class="pl-k">if</span> (ngx_new_binary) {  
                <span class="pl-c1">ngx_start_worker_processes</span>(cycle, ccf-&gt;worker_processes,  
                                           NGX_PROCESS_RESPAWN);  
                <span class="pl-c1">ngx_start_cache_manager_processes</span>(cycle, <span class="pl-c1">0</span>);  
                ngx_noaccepting = <span class="pl-c1">0</span>;  

                <span class="pl-k">continue</span>;  
            }  

            <span class="pl-c1">ngx_log_error</span>(NGX_LOG_NOTICE, cycle-&gt;<span class="pl-c1">log</span>, <span class="pl-c1">0</span>, <span class="pl-s"><span class="pl-pds">"</span>reconfiguring<span class="pl-pds">"</span></span>);  

            <span class="pl-c">//初始化ngx_cycle_t结构体  </span>
            cycle = <span class="pl-c1">ngx_init_cycle</span>(cycle);  
            <span class="pl-k">if</span> (cycle == <span class="pl-c1">NULL</span>) {  
                cycle = (<span class="pl-c1">ngx_cycle_t</span> *) ngx_cycle;  
                <span class="pl-k">continue</span>;  
            }  

            ngx_cycle = cycle;  
            ccf = (<span class="pl-c1">ngx_core_conf_t</span> *) <span class="pl-c1">ngx_get_conf</span>(cycle-&gt;conf_ctx,  
                                                   ngx_core_module);  
            <span class="pl-c">//创建新的worker子进程  </span>
            <span class="pl-c1">ngx_start_worker_processes</span>(cycle, ccf-&gt;worker_processes,  
                                       NGX_PROCESS_JUST_RESPAWN);  
            <span class="pl-c1">ngx_start_cache_manager_processes</span>(cycle, <span class="pl-c1">1</span>);  

            <span class="pl-c">/* allow new processes to start */</span>  
            <span class="pl-c1">ngx_msleep</span>(<span class="pl-c1">100</span>);  

            live = <span class="pl-c1">1</span>;  
            <span class="pl-c">//向所有子进程发送QUIT信号  </span>
            <span class="pl-c1">ngx_signal_worker_processes</span>(cycle,  
                                        <span class="pl-c1">ngx_signal_value</span>(NGX_SHUTDOWN_SIGNAL));  
        }  


</pre></div>

<h1>
<a id="欢迎一起交流学习-" class="anchor" href="#%E6%AC%A2%E8%BF%8E%E4%B8%80%E8%B5%B7%E4%BA%A4%E6%B5%81%E5%AD%A6%E4%B9%A0-" aria-hidden="true"><span class="octicon octicon-link"></span></a>欢迎一起交流学习 </h1>

<p>在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流</p>

<ul>
<li>邮件(1031379296#qq.com, 把#换成@)</li>
<li>QQ: 1031379296</li>
<li>weibo: <a href="http://weibo.com/u/2786211992/home">@王发康</a>
</li>
</ul>

<h1>
<a id="thx" class="anchor" href="#thx" aria-hidden="true"><span class="octicon octicon-link"></span></a>Thx</h1>

<ul>
<li>chunshengsterATgmail.com</li>
</ul>

<h1>
<a id="author" class="anchor" href="#author" aria-hidden="true"><span class="octicon octicon-link"></span></a>Author</h1>

<ul>
<li>Linux\nginx\golang\c\c++爱好者</li>
<li>欢迎一起交流  一起学习# </li>
<li>Others say good and Others good</li>
</ul>
      </section>
      <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		          <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("nginx reload 的过程 性能的影响");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
